#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "ssd1366.h"
#include "fonts.h"

#define SDA_PIN   14
#define SCL_PIN   2

static const char *TAG = "trLightRemote";

#define OLED_CMD_SET_SEGMENT_NORMAL_MODE  0xA0
#define OLED_CMD_SET_SEGMENT_INVERSE_MODE 0xA1
#define OLED_CMD_SET_COM_NORMAL_MODE      0xC0
#define OLED_CMD_SET_COM_REMAP_MODE       0xC8
#define OLED_CMD_SET_DISABLE_SCROLL       0x2E
#define OLED_CHARGE_PUMP_ON               0x14
#define OLED_CHARGE_PUMP_OFF              0x10

#define OLED_CMD_SET_MEMORY_ADDR_MODE     0x20    // follow with 0x00 = HORZ mode = Behave like a KS108 graphic LCD
#define OLED_CMD_SET_COLUMN_RANGE         0x21    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x7F = COL127
#define OLED_CMD_SET_PAGE_RANGE           0x22    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x07 = PAGE7

typedef enum 
{
  _OVERRIDE = 0x00,
  _TRANSPARENT = 0x01
} _DRAW_t;

typedef enum 
{
  _BLACK = 0x00,
  _WHITE = 0x01
} _COLOR_t;

#define _WIDTH     128
#define _HEIGHT    32

#define _BUFFER_CMD_MAX    64
#define _BUFFER_DATA_MAX   (_WIDTH * _HEIGHT / 8)

#define _CONTROL_CMD_SINGLE    0x80
#define _CONTROL_CMD_STREAM    0x00
#define _CONTROL_DATA_SINGLE   0xC0
#define _CONTROL_DATA_STREAM   0x40

typedef struct 
{
  uint8_t CmdBufferIndex;
  uint8_t CmdBuffer[_BUFFER_CMD_MAX];
  uint8_t DataBuffer[_BUFFER_DATA_MAX+1];
} Buffer_t;

Buffer_t test_buffer = 
{
  .CmdBufferIndex = 0,
  .CmdBuffer = {_CONTROL_CMD_STREAM, 0},
  .DataBuffer = {_CONTROL_DATA_STREAM, 0}
};
//
//
//
typedef struct {
  int16_t MaskX1;
  int16_t MaskY1;
  int16_t MaskX2;
  int16_t MaskY2;
  uint8_t Inverted;
  int16_t Ticks;
  uint8_t Frames;
  uint8_t FPS;
} Disp_t;

Disp_t disp =
{
  .MaskX1 = 0,
  .MaskY1 = 0,
  .MaskX2 = _WIDTH,
  .MaskY2 = _HEIGHT
};
//
//
//
char *trColor[] = {" ", "RED", "GREEN", "BLUE", "ALL"};
char *trOpers[] = {" ", "+", "++", "ON", "OFF"};
char trCursor = 0x7f;

typedef enum
{
  CW = 0,
  CCW
} _DIR_t;

typedef struct
{
  _DIR_t    dir;
  FontDef_t font;
  int       x_position;
  int       y_position;
  int       color_idx;
  int       opers_idx;
} _INPUT_t;
//
// encoder
//
#define GPIO_ENCODER_SW       16
#define GPIO_ENCODER_SW_PIN   (1ULL<<GPIO_ENCODER_SW)
#define GPIO_ENCODER_B        4
#define GPIO_ENCODER_A        5
#define GPIO_ENCODER_AB_PINS  ((1ULL<<GPIO_ENCODER_B) | (1ULL<<GPIO_ENCODER_A))


xQueueHandle gpio_evt_queue_a = NULL;
xQueueHandle gpio_evt_queue_b = NULL;

//
// prototypes
//
void _WriteString(int16_t x, int16_t y, char* str, FontDef_t* Font, _COLOR_t color, _DRAW_t mode);
void _WriteChar(int16_t x, int16_t y, char ch, FontDef_t* Font, _COLOR_t color, _DRAW_t mode);
void _Screen_Update(void);
void _DrawPixel(int16_t x, int16_t y, _COLOR_t color);
void _Clear(void);
void _Fill(_COLOR_t color);
static void encoder_display_update(_INPUT_t *input);
static void gpio_task_b(void *input);
static void gpio_task_a(void *input);

//volatile uint32_t a_count = 0, b_count = 0;
//
// because there is only one isr handler available for
// all the gpio pins, all the interrupts are processed
// through this one lone function
// sad...
//
static void gpio_isr_handler(void *arg)
{
  uint32_t gpio_num = (uint32_t) arg;
  if(gpio_num == GPIO_ENCODER_A)
    xQueueSendFromISR(gpio_evt_queue_a, &gpio_num, NULL);
  else
    xQueueSendFromISR(gpio_evt_queue_b, &gpio_num, NULL);
}
//
//
//
static void gpio_task_a(void *input)
{
  uint32_t io_num;
  uint32_t level_a, level_b;
  _INPUT_t *encoder = (_INPUT_t *)input;
  
  for (;;) {
    xQueueReceive(gpio_evt_queue_a, &io_num, portMAX_DELAY);
    xQueueReset(gpio_evt_queue_a);
    // here the edge of the interrupt is sorted out
    // since this is triggered by A, the B input
    // contains the history of the last event and 
    // knowing this is interrupt A and the current state
    // with that information, the direction of rotation 
    // can be determined
    level_a = gpio_get_level(GPIO_ENCODER_A);
    level_b = gpio_get_level(GPIO_ENCODER_B);
#if 0
    if(level_a == 1 && level_b == 1)
      // ccw
    else if(level_a == 1 && level_b == 0)
      // cw
    else if(level_a == 0 && level_b == 1)
      // cw
    else
      // ccw
#endif
    // try this
    //*(uint32_t *)dir = ~(level_a ^ level_b);
    //*(uint32_t *)dir &= 0x0001;
    uint32_t dir = ~(level_a ^ level_b);
    dir &= 0x0001;
    encoder->dir = (_DIR_t)dir;
    encoder_display_update(encoder);
    
    ESP_LOGI(TAG, "DIR : 0x%04x", encoder->dir);    
  }
}
//
//
//
static void gpio_task_b(void *input)
{
  uint32_t io_num;
  uint32_t level_a, level_b;
  _INPUT_t *encoder = (_INPUT_t *)input;
  
  for (;;) {
    xQueueReceive(gpio_evt_queue_b, &io_num, portMAX_DELAY);
    xQueueReset(gpio_evt_queue_b);
    
    level_a = gpio_get_level(GPIO_ENCODER_A);
    level_b = gpio_get_level(GPIO_ENCODER_B);
    
    uint32_t dir = (level_a ^ level_b) & 0x0001;
    encoder->dir = (_DIR_t)dir;
    encoder_display_update(input);

    ESP_LOGI(TAG, "DIR : 0x%04x", encoder->dir);
  }
}
//
//
//
#define MAXCOLORIDX   4
#define MINCOLORIDX   0
static void encoder_display_update(_INPUT_t *input)
{
  
  // update index
  if(input->dir == CW)
    input->color_idx++;
  else
    input->color_idx--;
  if(input->color_idx < MINCOLORIDX)
    input->color_idx = MAXCOLORIDX;
  if(input->color_idx > MAXCOLORIDX)
    input->color_idx = MINCOLORIDX;
    
  // test for over/under flow
  // then apply update to display
  _Clear();
  _WriteChar(0, 0, trCursor, &input->font, _WHITE, _OVERRIDE);
  _WriteString(input->x_position, input->y_position, trColor[input->color_idx], &input->font, _WHITE, _OVERRIDE);
  _Screen_Update();
}
#if 0
static void ccw_task(void *arg)
{
  xQueueReceive(
}
#endif
//
// encoder gpio 
//
static void gpio_init(_INPUT_t *input)
{
  gpio_config_t io_conf;

  // encoder switch input
  // polled input
  // disable interrupt
  io_conf.intr_type = GPIO_INTR_DISABLE;
  // set as input mode
  io_conf.mode = GPIO_MODE_INPUT;
  //bit mask of the input pin GPIO16
  io_conf.pin_bit_mask = GPIO_ENCODER_SW_PIN;
  //disable pull-down mode
  io_conf.pull_down_en = 0;
  //disable pull-up mode
  io_conf.pull_up_en = 0;
  //configure GPIO with the given settings
  gpio_config(&io_conf);
  
  // encoder ab inputs
  // interrupt on any edge
  io_conf.intr_type = GPIO_INTR_ANYEDGE;
  // bit mask of the pins, use GPIO4/5 here
  io_conf.pin_bit_mask = GPIO_ENCODER_AB_PINS;
  // set as input mode
  io_conf.mode = GPIO_MODE_INPUT;
  // disable pull-up mode
  io_conf.pull_up_en = 0;
  gpio_config(&io_conf);

  // create a queue to handle gpio event from isr
  gpio_evt_queue_a = xQueueCreate(10, sizeof(uint32_t));
  gpio_evt_queue_b = xQueueCreate(10, sizeof(uint32_t));
  // start gpio task
  //xTaskCreate(gpio_task_a, "gpio_task_a", 2048, (void *)dir, 10, NULL);
  //xTaskCreate(gpio_task_b, "gpio_task_b", 2048, (void *)dir, 10, NULL);
  xTaskCreate(gpio_task_a, "gpio_task_a", 2048, (void *)input, 10, NULL);
  xTaskCreate(gpio_task_b, "gpio_task_b", 2048, (void *)input, 10, NULL);
  
  // install gpio isr service
  gpio_install_isr_service(0);
  // hook isr handler for specific gpio pin - 4
  gpio_isr_handler_add(GPIO_ENCODER_B, gpio_isr_handler, (void *) GPIO_ENCODER_B);
  // hook isr handler for specific gpio pin - 5
  gpio_isr_handler_add(GPIO_ENCODER_A, gpio_isr_handler, (void *) GPIO_ENCODER_A);
  
}
//
// display
//
static void i2c_master_init(void)
{
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN,
		.scl_io_num = SCL_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
    .clk_stretch_tick = 300
	};
	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER);
	i2c_param_config(I2C_NUM_0, &i2c_config);
}
//
//
//

//
//
//
void _Fill(_COLOR_t color) 
{
  memset(test_buffer.DataBuffer + 1,
         (color == _BLACK) ? 0x00 : 0xFF,
         _BUFFER_DATA_MAX);
}

void _Clear(void) 
{
  _Fill(_BLACK);
}
//
//
//
void _DrawPixel(int16_t x, int16_t y, _COLOR_t color) 
{
  if(color == _WHITE) 
  {
    test_buffer.DataBuffer[1+ x + (y >> 3) * _WIDTH] |= (1 << (y % 8));
  } 
  else 
  {
    test_buffer.DataBuffer[1+ x + (y >> 3) * _WIDTH] &= ~(1 << (y % 8));
  }

}
//OLED_CONTROL_BYTE_DATA_STREAM
//
//
void _Screen_Update(void) 
{
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

  i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
  //i2c_master_write_byte(cmd, OLED_CMD_SET_MEMORY_ADDR_MODE, true);
  //i2c_master_write_byte(cmd, OLED
	//i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_OFF, true);           // turn display off
  
  i2c_master_write_byte(cmd, OLED_CMD_SET_COLUMN_RANGE, true); 
  i2c_master_write_byte(cmd, 0, true);  
  i2c_master_write_byte(cmd, _WIDTH-1, true);  
  i2c_master_write_byte(cmd, OLED_CMD_SET_PAGE_RANGE, true); 
  i2c_master_write_byte(cmd, 0, true);  
  i2c_master_write_byte(cmd, (_HEIGHT/8) -1, true);  
	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);           // turn display on
  //i2c_master_stop(cmd);
  espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 100/portTICK_PERIOD_MS);
  if(ESP_OK == espRc)
    ESP_LOGI(TAG, "display update successful");
  else
    ESP_LOGI(TAG, "display update failed  code: 0x%.2X", espRc);

 	i2c_cmd_link_delete(cmd);
  cmd = i2c_cmd_link_create();
  
  
  i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	//i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
  i2c_master_write(cmd, &test_buffer.DataBuffer[0], _BUFFER_DATA_MAX +1, true);
  i2c_master_stop(cmd);
  espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 100/portTICK_PERIOD_MS);
  if(ESP_OK == espRc)
    ESP_LOGI(TAG, "display data update successful");
  else
    ESP_LOGI(TAG, "display data update failed  code: 0x%.2X", espRc);
	
  i2c_cmd_link_delete(cmd);

}
//
//
//
void _WriteChar(int16_t x, int16_t y, char ch, FontDef_t* Font, _COLOR_t color, _DRAW_t mode)
{
    int16_t x0, y0, b;

    // Translate font to screen buffer
    for (y0 = 0; y0 < Font->height; y0++)
    {
        b = Font->data[(ch - 32) * Font->height + y0];
        for (x0 = 0; x0 < Font->width; x0++)
        {
            if ((b << x0) & 0x8000)
            {
              _DrawPixel(x + x0, y + y0, (_COLOR_t) color);
            }
            else if (mode == _OVERRIDE)
            {
              _DrawPixel(x + x0, y + y0, (_COLOR_t)!color);
            }
        }
    }
}
//
//
//
void _WriteString(int16_t x, int16_t y, char* str, FontDef_t* Font, _COLOR_t color, _DRAW_t mode)
{
    int16_t l = strlen(str);
    if (
        (x + l*Font->width < disp.MaskX1) ||
        (disp.MaskX2 < x) ||
        (y + Font->height < disp.MaskY1) ||
        (disp.MaskY2 < y)
    ){
      return;
    }

    int16_t fx = (disp.MaskX1 - x) / Font->width;
    int16_t rx = (x - disp.MaskX2) / Font->width;
    char* estr = str + l;
    int16_t n = 0;


    // cut off characters which are out of masking box
    if (fx > 0) {
        str += fx;
        x += fx*Font->width;
    }

    if (rx > 0) {
      estr -= rx;
    }



    // Write until null-byte or the first cutoff char
    while (*str && str < estr)
    {
        _WriteChar(x + n*Font->width, y, *str, Font, color, mode);
        n++;
        str++;
    }
}
//
//
//
#if 0
static void _rotate_font(FontDef_t *font, FontDef_t *rot_font)
{
  rot_font->width = font->height;
  rot_font->height = font->width;
  
  for(int i=0; i<font->width; i++)
    for(int j=0; j<font->height; j++)
      rot_font->data[i] = (font->data[j] & (0x0100 << i)) << (7 - j);
}
#endif
//
//
//
static void tr_ssd1306_init(void) 
{
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_OFF, true);           // turn display off
  // OSC default=0x81
  i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_CLK_DIV, true);   // set up oscillator
  i2c_master_write_byte(cmd, 0x81, true);
  // Brightness in range 0~255, default=0x7F
  i2c_master_write_byte(cmd, OLED_CMD_SET_CONTRAST, true);          // contrast
  i2c_master_write_byte(cmd, 0x7f, true);
  // Memory Address Mode: Horizontal=0, Vertical=1, Page=default=2
  i2c_master_write_byte(cmd, OLED_CMD_SET_MEMORY_ADDR_MODE, true);  // horiz
  i2c_master_write_byte(cmd, 0x00, true);
  // Set Display Offset in range 0~63
  i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_OFFSET, true);
  i2c_master_write_byte(cmd, 0x00, true);
  // Set Display start line in range 0x40~0x7F
  i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_START_LINE, true);
  // Set multiplex number (activated rows): rows=height-1, default=63
  // 128 x 32 display
  i2c_master_write_byte(cmd, OLED_CMD_SET_MUX_RATIO, true);
  i2c_master_write_byte(cmd, 0x31, true); 
  // Reduce a half of height??
  // set com pins - bits 5 / 4
  // bit 4 => 0 sequential com pin config
  // bit 5 => 0 disable com left/right remap
  i2c_master_write_byte(cmd, OLED_CMD_SET_COM_PIN_MAP, true);
  i2c_master_write_byte(cmd, 0x02, true);
  
  // Segment (Column) normal mode, Inverse=0xA1
  // set segment remap
  i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_NORMAL_MODE, true);
  // Common (Row) normal mode, inverse=0xC8
  // set com output scan direction
  i2c_master_write_byte(cmd, OLED_CMD_SET_COM_NORMAL_MODE, true);
  
  // disable entire display on
  i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_RAM, true);
  
  // Display normal mode, inverse=0xA7
  i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_NORMAL, true);
  // Disable Scroll
  i2c_master_write_byte(cmd, OLED_CMD_SET_DISABLE_SCROLL, true);
  // Pre-charge period, default=2
  i2c_master_write_byte(cmd, OLED_CMD_SET_PRECHARGE, true);
  i2c_master_write_byte(cmd, 0x02, true);
  // enable charge pump 0x14 => ON  0x10 => OFF
  i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP, true);
	i2c_master_write_byte(cmd, OLED_CHARGE_PUMP_ON, true);

	//i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_REMAP, true); // reverse left-right mapping
	//i2c_master_write_byte(cmd, OLED_CMD_SET_COM_SCAN_MODE, true); // reverse up-bottom mapping

	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
		ESP_LOGI(TAG, "OLED configured successfully");
	} else {
		ESP_LOGE(TAG, "OLED configuration failed. code: 0x%.2X", espRc);
	}
	i2c_cmd_link_delete(cmd);
  
}


void app_main(void)
{
  //uint32_t dir;
  _INPUT_t input =
  {
    .dir        = CCW,
    .font       = Font_8x8,
    .x_position = 8,
    .y_position = 0,
    .color_idx  = 0,
    .opers_idx  = 0
  };
  
	i2c_master_init();
	tr_ssd1306_init();
  gpio_init(&input);

  //FontDef_t rot_font;
  
  _Clear();
  _DrawPixel(0, 0, _WHITE);

  //_WriteString(0, 0, "1234567890123456789012345678901234567890", &font, _WHITE, _OVERRIDE);
//  _WriteChar(0, 0, 0x7f, &font, _WHITE, _OVERRIDE);
//  _WriteString(8, 0, "Red", &font, _WHITE, _OVERRIDE);
//  _WriteChar(48, 0, 0x7f, &font, _WHITE, _OVERRIDE);
//  _Screen_Update();

  ESP_LOGI(TAG, "SW : %d", gpio_get_level(GPIO_ENCODER_SW));
  ESP_LOGI(TAG, "!SW : %d", !gpio_get_level(GPIO_ENCODER_SW));
  
  #define BUSY 1
  #define AVAILABLE 0
  int stat = 0;
  
	while(1)
  {
    // 
    // poll for encoder button push
    // gpio enabled w pullup, so
    // looking for a negative going / low signal input
    //
#if 0    
    if(0 == gpio_get_level(GPIO_ENCODER_SW))
    {
      vTaskDelay(20/portTICK_PERIOD_MS);
      if(!(gpio_get_level(GPIO_ENCODER_SW)))
      {
        ESP_LOGI(TAG, "%d : %s", stat, trColor[stat]);
        //_WriteChar(0, 0, 0x7f, &font, _WHITE, _OVERRIDE);
        _WriteString(8, 0, trColor[stat], &font, _WHITE, _OVERRIDE);
        _Screen_Update();
        stat++;
        if(stat >= 4)
          stat = 0;

        while(!(gpio_get_level(GPIO_ENCODER_SW)))
          vTaskDelay(80/portTICK_PERIOD_MS);
      }
    }
#endif    

    vTaskDelay(80/portTICK_PERIOD_MS);
  }
}
