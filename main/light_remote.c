#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "driver/pwm.h"
#include "esp_err.h"
#include "esp_log.h"

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/timers.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "ssd1366.h"
#include "fonts.h"

#define SDA_PIN   14
#define SCL_PIN   2

static const char *TAG = "trLightRemote";
static const char *ENC_TAG = "encoder_poll";

#define OLED_CMD_SET_SEGMENT_NORMAL_MODE  0xA0
#define OLED_CMD_SET_SEGMENT_INVERSE_MODE 0xA1
#define OLED_CMD_SET_COM_NORMAL_MODE      0xC0
#define OLED_CMD_SET_COM_REMAP_MODE       0xC8
#define OLED_CMD_SET_DISABLE_SCROLL       0x2E
#define OLED_CHARGE_PUMP_ON               0x14
#define OLED_CHARGE_PUMP_OFF              0x10

#define OLED_CMD_SET_MEMORY_ADDR_MODE     0x20    // follow with 0x00 = HORZ mode = Behave like a KS108 graphic LCD
#define OLED_CMD_SET_COLUMN_RANGE         0x21    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x7F = COL127
#define OLED_CMD_SET_PAGE_RANGE           0x22    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x07 = PAGE7

typedef enum 
{
  _OVERRIDE = 0x00,
  _TRANSPARENT = 0x01
} _DRAW_t;

typedef enum 
{
  _BLACK = 0x00,
  _WHITE = 0x01
} _COLOR_t;

#define _WIDTH     128
#define _HEIGHT    32

#define _BUFFER_CMD_MAX    64
#define _BUFFER_DATA_MAX   (_WIDTH * _HEIGHT / 8)

#define _CONTROL_CMD_SINGLE    0x80
#define _CONTROL_CMD_STREAM    0x00
#define _CONTROL_DATA_SINGLE   0xC0
#define _CONTROL_DATA_STREAM   0x40

typedef struct 
{
  uint8_t CmdBufferIndex;
  uint8_t CmdBuffer[_BUFFER_CMD_MAX];
  uint8_t DataBuffer[_BUFFER_DATA_MAX+1];
} Buffer_t;

Buffer_t test_buffer = 
{
  .CmdBufferIndex = 0,
  .CmdBuffer = {_CONTROL_CMD_STREAM, 0},
  .DataBuffer = {_CONTROL_DATA_STREAM, 0}
};
//
//
//
#if 0
typedef struct {
  int16_t MaskX1;
  int16_t MaskY1;
  int16_t MaskX2;
  int16_t MaskY2;
  uint8_t Inverted;
  int16_t Ticks;
  uint8_t Frames;
  uint8_t FPS;
} Disp_t;
Disp_t disp =
{
  .MaskX1 = 0,
  .MaskY1 = 0,
  .MaskX2 = _WIDTH,
  .MaskY2 = _HEIGHT
};
#endif
//
// LED
//
typedef struct
{
  // _INPUT_t
  FontDef_t font;
  int       x;
  int       y;
  // Disp_t
  int16_t   MaskX1;
  int16_t   MaskY1;
  int16_t   MaskX2;
  int16_t   MaskY2;
  // new
  char      cursor;
  uint16_t  *cursor_pos;  // {{x,y}, {x,y}, ...}
  //char    *led_color;	  // trColor

  uint8_t   rgb[3];       // [0-255][][]
  uint16_t  *rgb_pos;     // {{x,y}, {x,y}, ...}

  bool    led_active;
} LED_display_t;

typedef enum
{
  RED   = 0,
  GREEN,
  BLUE
} LED_color_t;
//
//
//
char *trColor[] = {"ON", "OFF", "RED", "GREEN", "BLUE", "ALL"};
char trCursor = 0x7f;
//const uint16_t cursor_position[4][2] = {{24, 0}, {8, 16}, {48, 16}, {88, 16}};
//const uint16_t rgb_position[3][2]    = {{16, 16}, {56, 16}, {96, 16}};
uint16_t cursor_position[] = {24, 0, 8, 16, 48, 16, 88, 16};
uint16_t rgb_position[]    = {16, 16, 56, 16, 96, 16};

typedef enum
{
  CW = 0,
  CCW
} _DIR_t;

typedef struct
{
  _DIR_t    dir;
  bool      active;
  int       index;  // trColor index
} ENCODER_t;
#if 0
typedef struct
{
  _DIR_t    dir;
  FontDef_t font;
  int       x_position;
  int       y_position;
  int       color_idx;
  int       opers_idx;
} _INPUT_t;
#endif
//
// encoder
//
#define GPIO_ENCODER_SW       16
#define GPIO_ENCODER_SW_PIN   (1ULL<<GPIO_ENCODER_SW)
#define GPIO_PWM_INPUT        15
#define GPIO_PWM_INPUT_PIN    (1ULL<<GPIO_PWM_INPUT)
#define GPIO_ENCODER_B        4
#define GPIO_ENCODER_A        5
#define GPIO_ENCODER_AB_PINS  ((1ULL<<GPIO_ENCODER_B) | (1ULL<<GPIO_ENCODER_A))
#define GPIO_ENCODER_PINS     (GPIO_ENCODER_AB_PINS | (1ULL<<GPIO_ENCODER_SW))

#define PWM_PERIOD    (100000)
#define PWM_0_OUT_IO_NUM   12

xQueueHandle gpio_evt_queue_a   = NULL;
xQueueHandle gpio_evt_queue_b   = NULL;
xQueueHandle gpio_evt_queue_pwm = NULL;
//xQueueHandle gpio_evt_queue_sw  = NULL;

volatile int timer_intr_counter;

typedef struct
{
	ENCODER_t     *encoder;
	LED_display_t *display;
} GPIO_TASK_t;

//
// prototypes
//
void _Clear_String(LED_display_t *display, int16_t string_length, _DRAW_t mode);
void _WriteString(LED_display_t *display, char *str, _COLOR_t color, _DRAW_t mode);
void _WriteChar(LED_display_t *display, char ch, _COLOR_t color, _DRAW_t mode);
void _Screen_Update(void);
void _DrawPixel(int16_t x, int16_t y, _COLOR_t color);
void _Clear(void);
void _Fill(_COLOR_t color);
static void color_index_update(GPIO_TASK_t *task);
static void color_display_update(GPIO_TASK_t *task);

//static void encoder_display_update(_INPUT_t *input);
static void gpio_task_b(void *arg);
static void gpio_task_a(void *arg);
static void gpio_task_pwm(void *arg);

//volatile uint32_t a_count = 0, b_count = 0;
//
// because there is only one isr handler available for
// all the gpio pins, all the interrupts are processed
// through this one lone function
// sad...
//
static void gpio_isr_handler(void *arg)
{
  uint32_t gpio_num = (uint32_t) arg;
  
  if(gpio_num == GPIO_ENCODER_A)
    xQueueSendFromISR(gpio_evt_queue_a, &gpio_num, NULL);
  else if(gpio_num == GPIO_ENCODER_B)
    xQueueSendFromISR(gpio_evt_queue_b, &gpio_num, NULL);
  else if(gpio_num == GPIO_PWM_INPUT)
    xQueueSendFromISR(gpio_evt_queue_pwm, &gpio_num, NULL);
  else
  {}
  
}
//
//
//
static void gpio_task_a(void *arg)
{
  uint32_t io_num;
  uint32_t level_a, level_b;
  GPIO_TASK_t *task = (GPIO_TASK_t *)arg;
  
  for (;;) {
    xQueueReceive(gpio_evt_queue_a, &io_num, portMAX_DELAY);
    xQueueReset(gpio_evt_queue_a);
    
    timer_intr_counter = 1;
    
    // here the edge of the interrupt is sorted out
    // since this is triggered by A, the B input
    // contains the history of the last event and 
    // knowing this is interrupt A and the current state
    // with that information, the direction of rotation 
    // can be determined
    level_a = gpio_get_level(GPIO_ENCODER_A);
    level_b = gpio_get_level(GPIO_ENCODER_B);
#if 0
    if(level_a == 1 && level_b == 1)
      // ccw
    else if(level_a == 1 && level_b == 0)
      // cw
    else if(level_a == 0 && level_b == 1)
      // cw
    else
      // ccw
#endif
    // try this
    //*(uint32_t *)dir = ~(level_a ^ level_b);
    //*(uint32_t *)dir &= 0x0001;
    uint32_t dir = ~(level_a ^ level_b);
    dir &= 0x0001;
    task->encoder->dir = (_DIR_t)dir;
    color_index_update(task);
    
    ESP_LOGI(TAG, "DIR : 0x%04x", task->encoder->dir);    
  }
}
//
//
//
static void gpio_task_b(void *arg)
{
  uint32_t io_num;
  uint32_t level_a, level_b;
  GPIO_TASK_t *task = (GPIO_TASK_t *)arg;
  
  for (;;) {
    xQueueReceive(gpio_evt_queue_b, &io_num, portMAX_DELAY);
    xQueueReset(gpio_evt_queue_b);
    
    timer_intr_counter = 1;
    
    level_a = gpio_get_level(GPIO_ENCODER_A);
    level_b = gpio_get_level(GPIO_ENCODER_B);
    
    uint32_t dir = (level_a ^ level_b) & 0x0001;
    task->encoder->dir = (_DIR_t)dir;
    color_index_update(task);

    ESP_LOGI(TAG, "DIR : 0x%04x", task->encoder->dir);
  }
}
//
//
//
#define TIMEOUT 50
static void gpio_task_pwm(void *arg)
{
  uint32_t io_num;
  
  for(;;)
  {
    xQueueReceive(gpio_evt_queue_pwm, &io_num, portMAX_DELAY);
    xQueueReset(gpio_evt_queue_pwm);
    timer_intr_counter++;
    ESP_LOGI(TAG, "callback");
    if(0 == (timer_intr_counter % TIMEOUT))
    {
      pwm_stop(0);
      timer_intr_counter = 1;
      _Clear();
      _Screen_Update();
    }
  }
}
//
//
//
#define MAXCOLORIDX   5
#define MINCOLORIDX   0
//static void encoder_display_update(_INPUT_t *input)
static void color_index_update(GPIO_TASK_t *task)
{
  
  // update index
  if(task->encoder->dir == CW)
    task->encoder->index++;
  else
    task->encoder->index--;
  if(task->encoder->index < MINCOLORIDX)
    task->encoder->index = MAXCOLORIDX;
  if(task->encoder->index > MAXCOLORIDX)
    task->encoder->index = MINCOLORIDX;
    
  // test for over/under flow
  // then apply update to display
  //_Clear();
  task->display->x = 16;
  task->display->y = 0;
  color_display_update(task);
}
//
//
//
static void color_display_update(GPIO_TASK_t *task)
{
  int tmp_x = task->display->x;
  int tmp_y = task->display->y;
  _Clear_String(task->display, 7, _OVERRIDE);
  task->display->x = tmp_x;
  task->display->y = tmp_y;

  _WriteString(task->display, trColor[task->encoder->index], _WHITE, _OVERRIDE);
  _Screen_Update();
  
}
//
// encoder gpio 
//
static void gpio_init(GPIO_TASK_t *task)
{
  gpio_config_t io_conf;

  // encoder switch input
  // interrupt on low going edge
  io_conf.intr_type = GPIO_INTR_DISABLE;
  // set as input mode
  io_conf.mode = GPIO_MODE_INPUT;
  //bit mask of the input pin
  io_conf.pin_bit_mask = GPIO_ENCODER_SW_PIN;
  //disable pull-down mode
  io_conf.pull_down_en = 0;
  //disable pull-up mode
  // input is pulled high externally
  io_conf.pull_up_en = 0;
  //configure GPIO with the given settings
  gpio_config(&io_conf);
  
  ESP_LOGI(TAG, "encoder switch pin %d", GPIO_ENCODER_SW);
  
  // encoder ab inputs
  // interrupt on any edge
  io_conf.intr_type = GPIO_INTR_ANYEDGE;
  // bit mask of the pins, use GPIO4/5 here
  io_conf.pin_bit_mask = GPIO_ENCODER_AB_PINS;
  // set as input mode
  io_conf.mode = GPIO_MODE_INPUT;
  // disable pull-up mode
  io_conf.pull_up_en = 0;
  gpio_config(&io_conf);

  ESP_LOGI(TAG, "encoder ab pins %d/%d", GPIO_ENCODER_A, GPIO_ENCODER_B);
  
  // pwm input
  // interrupt on neg edge
  io_conf.intr_type = GPIO_INTR_NEGEDGE;
  // bit mask of the pins, use GPIO4/5 here
  io_conf.pin_bit_mask = GPIO_PWM_INPUT_PIN;
  // set as input mode
  io_conf.mode = GPIO_MODE_INPUT;
  // disable pull-up mode
  io_conf.pull_up_en = 0;
  gpio_config(&io_conf);

  ESP_LOGI(TAG, "PWM pins %d", GPIO_PWM_INPUT);
  
  // create a queue to handle gpio event from isr
  gpio_evt_queue_a  = xQueueCreate(10, sizeof(uint32_t));
  gpio_evt_queue_b  = xQueueCreate(10, sizeof(uint32_t));
  gpio_evt_queue_pwm = xQueueCreate(10, sizeof(uint32_t));
  //gpio_evt_queue_sw = xQueueCreate(10, sizeof(uint32_t));
  ESP_LOGI(TAG, "queue");

// start gpio task
  xTaskCreate(gpio_task_a,  "gpio_task_a",  2048, (void *)task, 10, NULL);
  xTaskCreate(gpio_task_b,  "gpio_task_b",  2048, (void *)task, 10, NULL);
  xTaskCreate(gpio_task_pwm, "gpio_task_pwm", 2048, NULL, 10, NULL);
  //xTaskCreate(gpio_task_sw, "gpio_task_sw", 2048, (void *)input, 10, NULL);
    ESP_LOGI(TAG, "create");

  // install gpio isr service
  gpio_install_isr_service(0);
  // hook isr handler to gpio pin 4
  gpio_isr_handler_add(GPIO_ENCODER_B, gpio_isr_handler, (void *) GPIO_ENCODER_B);
  // hook isr handler to gpio pin 5
  gpio_isr_handler_add(GPIO_ENCODER_A, gpio_isr_handler, (void *) GPIO_ENCODER_A);
  //
  gpio_isr_handler_add(GPIO_PWM_INPUT, gpio_isr_handler, (void *) GPIO_PWM_INPUT);
  // hook isr handler to gpio pin 16
  //gpio_isr_handler_add(GPIO_ENCODER_SW, gpio_isr_handler, (void *) GPIO_ENCODER_SW);
  ESP_LOGI(TAG, "gpio done");
  
}
//
// display
//
static void i2c_master_init(void)
{
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN,
		.scl_io_num = SCL_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
    .clk_stretch_tick = 300
	};
	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER);
	i2c_param_config(I2C_NUM_0, &i2c_config);
}
//OLED_CONTROL_BYTE_DATA_STREAM
//
//
void _Screen_Update(void) 
{
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

  i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
  
  i2c_master_write_byte(cmd, OLED_CMD_SET_COLUMN_RANGE, true); 
  i2c_master_write_byte(cmd, 0, true);  
  i2c_master_write_byte(cmd, _WIDTH-1, true);  
  i2c_master_write_byte(cmd, OLED_CMD_SET_PAGE_RANGE, true); 
  i2c_master_write_byte(cmd, 0, true);  
  i2c_master_write_byte(cmd, (_HEIGHT/8) -1, true);  
	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);           // turn display on

  espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 100/portTICK_PERIOD_MS);
  if(ESP_OK == espRc)
    ESP_LOGI(TAG, "display update successful");
  else
    ESP_LOGI(TAG, "display update failed  code: 0x%.2X", espRc);

 	i2c_cmd_link_delete(cmd);
  cmd = i2c_cmd_link_create();
  
  
  i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

  i2c_master_write(cmd, &test_buffer.DataBuffer[0], _BUFFER_DATA_MAX +1, true);
  i2c_master_stop(cmd);
  espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 100/portTICK_PERIOD_MS);
  if(ESP_OK == espRc)
    ESP_LOGI(TAG, "display data update successful");
  else
    ESP_LOGI(TAG, "display data update failed  code: 0x%.2X", espRc);
	
  i2c_cmd_link_delete(cmd);

}
//
//
//
void _Fill(_COLOR_t color) 
{
  memset(test_buffer.DataBuffer + 1,
         (color == _BLACK) ? 0x00 : 0xFF,
         _BUFFER_DATA_MAX);
}
//
//
//
void _Clear(void) 
{
  _Fill(_BLACK);
}
//
//
//
void _DrawPixel(int16_t x, int16_t y, _COLOR_t color) 
{
  if(color == _WHITE) 
  {
    test_buffer.DataBuffer[1+ x + (y >> 3) * _WIDTH] |= (1 << (y % 8));
  } 
  else 
  {
    test_buffer.DataBuffer[1+ x + (y >> 3) * _WIDTH] &= ~(1 << (y % 8));
  }

}
//
//
//
void _WriteChar(LED_display_t *display, char ch, _COLOR_t color, _DRAW_t mode)
{
    int16_t x0, y0, b;

    // Translate font to screen buffer
    for (y0 = 0; y0 < display->font.height; y0++)
    {
      b = display->font.data[(ch - 32) * display->font.height + y0];
      for (x0 = 0; x0 < display->font.width; x0++)
      {
        if ((b << x0) & 0x8000)
        {
          _DrawPixel(display->x + x0, display->y + y0, (_COLOR_t) color);
        }
        else if (mode == _OVERRIDE)
        {
          _DrawPixel(display->x + x0, display->y + y0, (_COLOR_t)!color);
        }
      }
    }
}
//
//
//
void _WriteString(LED_display_t *display, char *str, _COLOR_t color, _DRAW_t mode)
{
    int16_t l = strlen(str);
    if (
        (display->x + l*display->font.width < display->MaskX1) ||
        (display->MaskX2 < display->x) ||
        (display->y + display->font.height < display->MaskY1) ||
        (display->MaskY2 < display->y)
    )
    {
      ESP_LOGE(TAG, "writestring init test");
      return;
    }

    int16_t fx = (display->MaskX1 - display->x) / display->font.width;
    int16_t rx = (display->x - display->MaskX2) / display->font.width;
    char* estr = str + l;
    ESP_LOGI(TAG, "0x%x = 0x%x + 0x%x", (uint16_t)estr, (uint16_t)str, (uint16_t)l);
    


    // cut off characters which are out of masking box
    if (fx > 0) {
        str += fx;
        display->x += fx*display->font.width;
    }

    if (rx > 0) {
      estr -= rx;
    }



    // Write until null-byte or the first cutoff char
    int tmp_x = display->x;
    ESP_LOGI(TAG, "%d = %d", tmp_x, display->x);
    display->y = 0;
    int16_t n = 0;
    while (*str && str < estr)
    {
      display->x = tmp_x + n * display->font.width;
      _WriteChar(display, *str, color, mode);
      n++;
      str++;
    }
}
//
//
//
void _Clear_String(LED_display_t *display, int16_t string_length, _DRAW_t mode)
{
  int16_t l = string_length;
  char s[string_length];
  memset(s, ' ', string_length);
  char *str = s;
  
  _WriteString(display, str, _WHITE, mode);
  
}
//
//
//
static void tr_ssd1306_init(void) 
{
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_OFF, true);           // turn display off
  // OSC default=0x81
  i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_CLK_DIV, true);   // set up oscillator
  i2c_master_write_byte(cmd, 0x81, true);
  // Brightness in range 0~255, default=0x7F
  i2c_master_write_byte(cmd, OLED_CMD_SET_CONTRAST, true);          // contrast
  i2c_master_write_byte(cmd, 0x7f, true);
  // Memory Address Mode: Horizontal=0, Vertical=1, Page=default=2
  i2c_master_write_byte(cmd, OLED_CMD_SET_MEMORY_ADDR_MODE, true);  // horiz
  i2c_master_write_byte(cmd, 0x00, true);
  // Set Display Offset in range 0~63
  i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_OFFSET, true);
  i2c_master_write_byte(cmd, 0x00, true);
  // Set Display start line in range 0x40~0x7F
  i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_START_LINE, true);
  // Set multiplex number (activated rows): rows=height-1, default=63
  // 128 x 32 display
  i2c_master_write_byte(cmd, OLED_CMD_SET_MUX_RATIO, true);
  i2c_master_write_byte(cmd, 0x31, true); 
  // Reduce a half of height??
  // set com pins - bits 5 / 4
  // bit 4 => 0 sequential com pin config
  // bit 5 => 0 disable com left/right remap
  i2c_master_write_byte(cmd, OLED_CMD_SET_COM_PIN_MAP, true);
  i2c_master_write_byte(cmd, 0x02, true);
  
  // Segment (Column) normal mode, Inverse=0xA1
  // set segment remap
  i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_NORMAL_MODE, true);
  // Common (Row) normal mode, inverse=0xC8
  // set com output scan direction
  i2c_master_write_byte(cmd, OLED_CMD_SET_COM_NORMAL_MODE, true);
  
  // disable entire display on
  i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_RAM, true);
  
  // Display normal mode, inverse=0xA7
  i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_NORMAL, true);
  // Disable Scroll
  i2c_master_write_byte(cmd, OLED_CMD_SET_DISABLE_SCROLL, true);
  // Pre-charge period, default=2
  i2c_master_write_byte(cmd, OLED_CMD_SET_PRECHARGE, true);
  i2c_master_write_byte(cmd, 0x02, true);
  // enable charge pump 0x14 => ON  0x10 => OFF
  i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP, true);
	i2c_master_write_byte(cmd, OLED_CHARGE_PUMP_ON, true);

	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
		ESP_LOGI(TAG, "OLED configured successfully");
	} else {
		ESP_LOGE(TAG, "OLED configuration failed. code: 0x%.2X", espRc);
	}
	i2c_cmd_link_delete(cmd);
  
}

void app_main(void)
{
  // pwm pin number
  const uint32_t pin_num = PWM_0_OUT_IO_NUM;
  // duties table, real_duty = duties[x]/PERIOD
  uint32_t duties = PWM_PERIOD / 2;
  float phase = 0;
  
  
  
#if 0  
  _INPUT_t input =
  {
    .dir        = CCW,
    .font       = Font_8x8,
    .x_position = 8,
    .y_position = 0,
    .color_idx  = 0,
    .opers_idx  = 0
  };
#endif  
  LED_display_t display =
  {
    .font       = Font_8x8,
    .x          = 8,
    .y          = 0,
    .MaskX1     = 0,
    .MaskY1     = 0,
    .MaskX2     = _WIDTH,
    .MaskY2     = _HEIGHT,
    .cursor_pos = cursor_position,
    .rgb_pos    = rgb_position
    //.led_color  = {"ON", "OFF", "RED", "GREEN", "BLUE", "ALL"}
  };
  
  ENCODER_t encoder =
  {
    .dir        = CCW,
    .active     = false
  };
  
  GPIO_TASK_t task;
  task.encoder = &encoder;
  task.display = &display;
  
	i2c_master_init();
	tr_ssd1306_init();
  gpio_init(&task);
  pwm_init(PWM_PERIOD, &duties, 1, &pin_num);
  pwm_set_phases(&phase);
  pwm_stop(0);
  
  _Clear();
  _DrawPixel(0, 0, _WHITE);

  ESP_LOGI(TAG, "SW : %d", gpio_get_level(GPIO_ENCODER_SW));
  ESP_LOGI(TAG, "!SW : %d", !gpio_get_level(GPIO_ENCODER_SW));

	while(1)
  {
#if 1  
    // 
    // poll for encoder button push
    // gpio enabled w pullup, so
    // looking for a negative going / low signal input
    //

    if(0 == gpio_get_level(GPIO_ENCODER_SW))
    {
      vTaskDelay(20/portTICK_PERIOD_MS);
      if(!(gpio_get_level(GPIO_ENCODER_SW)))
      {
        // do some stuff here if required
        ESP_LOGI(TAG, "encoder sw");
        // wait for pb to open i.e. go low
        timer_intr_counter = 1;
        pwm_start();
        // display.x|y are dynamic
        // be very careful
        // check if lights are on i.e. active
        // adjust index into trColor as req'd
        if(display.led_active)
        {
        }
        else
        {
        }
        // activate encoder
        encoder.active = true;
        display.x = 8;
        display.y = 0;
        _WriteChar(&display, trCursor, _WHITE, _OVERRIDE);
        _Screen_Update();
        
        while(!(gpio_get_level(GPIO_ENCODER_SW)))
          vTaskDelay(80/portTICK_PERIOD_MS);
      }
    }
#endif
    vTaskDelay(80/portTICK_PERIOD_MS);
  }

    
  
}
